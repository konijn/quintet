<html>
  <head>
    <!--  -->
    <title>Mevarick</title>
    <style>
      body {background-color:black; color:white; white-space:pre; font-family:monospace; text-align:center }
      
    </style>
  </head>
  <body>
  <div id="screen"></div>
</body>

<script>
//constants
var WALL=0;FLOOR=1,hack="";

//2d map helpers
map2 = 
{ dump : function()
  {
    hack = "";
    this.apply( function(c){ if(c.dump)hack = hack + c.dump(c); });
    console.log( hack );
  },
  apply : function( f )
  {
    for( var y = 0 ; y < this.map2.y ; y++ )
      for( var x = 0 ; x < this.map2.x ; x++ )
        f( this[x][y] , this );
  },
  applyArea : function( from , to , f )
  {
    for( var y = min( from.y , to.y ) ; y < max( from.y , to.y ) ; y++ )
      for( var x = min( from.x , to.x ) ; x < max( from.x , to.x ); x++ )
        f( this[x][y] , this );      
  },
  applyRow : function( y , f )
  {
    for( var x = 0 ; x < this.map2.x ; x++ )
      f( [x][y] , this );
  },    
  applyColumn : function( x , f )
  {
    for( var y = 0 ; x < this.map2.y ; y++ )
      f( this[x][y] , this );
  },        
  applyBag : function( bag , f )
  {
     var cursor = this.cursor || { x : 0 , y : 0 };
     for( var i = 0 ; i < bag.length ; i++ )
     {
       cursor.x = bag[i].x || cursor.x;
       cursor.y = bag[i].y || cursor.y;         
       f( this[cursor.x][cursor.y] , bag[i] , this , bag  );
     }
  },    
  init : function( o, config ,f )
  {
    o.map2 = config;
    for( var x = 0 ; x < o.map2.x ; x++ )
      if( o[x] = [] ) //I might burn for this :P
        for( var y = 0 ; y < o.map2.y ; y++ )
          f( o[x][y] = o[x][y] || this.initCell(x,y,config) , x , y , o );
    for( key in map2 )
      o[key] = map2[key];
    return o;  
  },
  initCell : function( x, y , config )
  {
    var cell = { x : x , y : y };
    if( x == config.x - 1 )
      cell.eol = true;
    return cell;    
  },
  neighbours : function( cell , v/*ectors*/, f/*ilter*/ )
  {
    var set = [], maybe;
    for( var i = 0 ; i < v.length ; i++ )
      if( this[cell.x+v[i].x] )
        if( maybe = this[cell.x+v[i].x][cell.y+v[i].y] )
          if( !f || ( f && f( maybe ) ) )
            set.push( maybe );
    return set;    
  },
  allNeighbours: [ {x:0,y:-1},{x:0,y:1},{x:1,y:-1},{x:1,y:1},{x:1,y:0},{x:-1,y:-1},{x:-1,y:1},{x:-1,y:0} ],
  cardinalNeighbours : [{x:0,y:-1},{x:0,y:1},{x:1,y:0},{x:-1,y:0}]
}
    
function createCursor(parent,x,y,cursor)
{
  y = y || 0; x = x || 0,
  cursor = {
    parent : parent,
    color : cursor,
    x : x,
    y : y,
    advance : function()
    {
      this.x++;
      if( this.x == this.parent.w )
      {
        this.x = 0;
        this.y++;
        if( this.y == this.parent.h )
          this.y = 0;  
      }
    }
  }
  return cursor;
}    
    
    
//The screen  
screen = 
{
  h : 25, //h is height
  w : 80, //w is width
  cursor  : false, 
  div : document.getElementById("screen"),
  initialize : function()
  {
    map2.init( this , {  x : this.w , y : this.h } , function(c,x,y,o)
    { 
      c.char = 'o' , c.color = 'green' , c.eol = (x==o.map2.x-1) 
    });
    this.cursor = createCursor(this,0,0,false);
    console.log( "Hello World" );
    return this;
  },
  clear: function()
  {
    this.apply( function(c){ c.char = '&nbsp;' } );
    return this;
  },
  print: function( s , color )
  {
     var oldColor = this.cursor.color;
     if(color) 
       this.cursor.color = color;

     this.applyBag( s.split("") , function( c , entry, o )
     {
       c.color = o.cursor.color || c.color;
       c.char = entry;  
       o.cursor.advance();
     });
     
     if(color) 
       this.cursor.color = oldColor;     
     return this;
  },
  write : function()
  {
    this.html = '';
    this.apply( function(c,o)
    { 
      o.html = o.html + c.char + (c.eol?"<br>":"") 
    });
    //console.log( this.html );
    this.div.innerHTML = this.html;
    return this;
  }
}.initialize().clear().print("Hello World").write();


function Map(config)
{
  if ( !(this instanceof Map) )
      return new Map();

  for( key in config )
    this[key] = config[key];
}

Map.prototype.dumpCell = function( cell )
{
  var eol = cell.eol?"\n":""  
  if( cell.feature == WALL )
    return "#"+eol;
  if( cell.feature == FLOOR )
    return "."+eol;    
  return "Â¿"+eol;
}


//http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php
function dungeonGenerator( config )
{ //Initialize Grid
  var grid = map2.init( { cells:[] } , { x:config.grid.w , y:config.grid.h } , function(){});
  //Create the list of neighbours, collect all the cells  
  grid.apply( function(cell,grid)
  {
    cell.neighbours = grid.neighbours( cell , grid.allNeighbours );
    grid.cells.push(cell);
  });
  //Randomize the list of cells
  grid.cells = grid.cells.shuffle();
  //Visit the grid
  grid.cells.each( function(cell)
  {
    grid.applyBag( [cell] , function( cell , ignore1 , ignore2 , bag )    
    {
      if(!cell.connected)
      {
        for(var i = 0 ; i < cell.neighbours.length; i++)
        {
          var neighbour = cell.neighbours[i];  
          if( !neighbour.connected )
          {
            cell.connected = neighbour.connected = true;
            cell.connectedTo = ( cell.connectedTo || [] ).concat( neighbour );
            neighbour.connectedTo  = ( neighbour.connectedTo || [] ).concat( cell );
            bag.push[cell.neighbours[i]];
            return;
          }
        }
        //So, all neighbours are connected, very disconcerting :]
        var neighbour = cell.neighbours.random();    
        cell.connected = true;          
        cell.connectedTo = ( cell.connectedTo || [] ).concat( neighbour );
        neighbour.connectedTo = ( neighbour.connectedTo || [] ).concat( cell );          
      }    
    });
  });
  console.log( grid );
  var map = map2.init( {} , { x:config.map.w , y:config.map.h } , function(c)
  {
    c.feature = WALL;
    c.dump = Map.prototype.dumpCell;
  });
  console.log( map );
  var xMultiple =  Math.floor(config.map.w / ( config.grid.w+1 ));
  var yMultiple =  Math.floor(config.map.h / ( config.grid.h+1 ));    
  grid.cells.each( function( cell )
  {
      cell.x = (cell.x+1)*xMultiple;
      cell.y = (cell.y+1)*yMultiple;      
  });
  grid.cells.each( function( cell )
  {
    cell.connectedTo.each( function( to )
    {
      console.log( cell , to );
      map.applyArea( cell, to , function( cell ){ cell.feature = FLOOR });
    });
  });        
  map.dump();
  

}




//Protype magic                       
                       
Array.prototype.shuffle = function()
{
  var out = [] , tmp = this , idx; 
  while( tmp.length )
  {
    out.push( tmp[idx = Math.floor(tmp.length * Math.random())] );
    tmp = tmp.slice( 0 , idx ).concat( tmp.slice( idx + 1 ) );                  
  }
  return out;  
}

Array.prototype.random = function()
{
  return this[ Math.floor(this.length * Math.random() ) ]
}          
          
Array.prototype.each = function(f)
{
  for( var i = 0 ; i < this.length ; i++)
    f(this[i],this);
}

//Silly magic    
var a = Object.getOwnPropertyNames(Math);    
for( key in a ) this[a[key]] = Math[a[key]]; 
    
dungeonGenerator( { grid : { w:4 , h:3 } , map : { w:80 , h:25 } } );
  
</script>
</html>
